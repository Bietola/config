#! /usr/bin/env nix-shell
#! nix-shell -i python -p python39 python39Packages.pyyaml

import re
import sys
import yaml

###########
# Globals #
###########

env = {}
cached_exps = {}
lines = []

#######################
# Precompiles regexes #
#######################

# Warning: First capture group of these must be the indent
keyval_pair_re = re.compile('^(\s*)(.*?)\s*:(.>)?\s*(.*)$')
new_subscope_re = re.compile('^(\s*)(.*?):\s*$')

whitespace_re = re.compile('^\s*$')
list_ele_re = re.compile('^\s*-.*$')
heading_re = re.compile('^#.*$')

####################
# Helper functions #
####################

def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

def add_scope(scope, s):
    if len(scope) > 0:
        return '.'.join(scope) + '.' + s

    return s

def dict_add_dotted_str(d, s, val, err_on_present = False):
    splt_s = s.split('.', 1)
    topkey = splt_s[0]
    rest = splt_s[1] if len(splt_s) == 2 else None

    if rest:
        if not d.get(topkey, None):
            d[topkey] = {}
        dict_add_dotted_str(d[topkey], rest, val, err_on_present)
    else:
        # TODO: Check for duplicates
        d[topkey] = val

def dict_get_w_dotted_key(d, s):
    splt_s = s.split('.', 1)
    topkey = splt_s[0]
    rest = splt_s[1] if len(splt_s) == 2 else None

    if rest == None:
        return d.get(topkey, None)
    elif not d.get(topkey, None):
        return None
    else:
        return dict_get_w_dotted_key(d[topkey], rest)

def do_eval_in_sub(scope, m):
    indent = m.group(1)
    name = m.group(2)
    control_seq = m.group(3)
    exp = m.group(4)

    str_key = indent + name
    name = add_scope(scope, name)
    control_char = control_sequence[0] # e.g.: from "E>" to "E"

    if control_char == "$":
        dict_add_dotted_str(cached_exps, name, exp)
        val = do_eval_interpolation(exp, scope)
        return str_key + ":#> " + str(val)

    elif control_char == "#" or control_char == "S" or control_char == "E":
        if cached_exp := dict_get_w_dotted_key(cached_exps, name):
            if control_char == "#":
                val = do_eval_interpolation(cached_exp, scope)
            elif control_char == "S":
                val = cached_exp
            elif control_char == "E":
                val = cached_exp
                control_char = "$"

            return str_key + ":" + control_char + "> " + str(val)

    else:
        return str_key + ":" + control_char + "> " + "Error: Unknown control character: " + control_char

def is_op(s):
    return (s == "+" or s == "-" or s == "/" or s == "*")

def is_float(value):
  try:
    float(value)
    return True
  except:
    return False

def do_eval_interpolation(interpolated_str, scope):
    return re.sub(
        r'\$\{(.*?)\}',
        lambda m: str(do_eval_w_err(m.group(1), scope)),
        interpolated_str
    )

def do_eval_w_err(exp, scope):
    val = do_eval(exp, scope)
    if not val:
        return "Error: No expression cached for " + name
    else:
        return val

def do_eval(exp, scope):
    exp_w_subs = []
    for word in exp.split():
        if is_op(word) or is_float(word):
            exp_w_subs.append(word)
        else:
            if word[0] == '.':
                word = add_scope(scope, word[1:])

            val = dict_get_w_dotted_key(env, word)
            if val == None:
                return "Error: No variable named \"" + word + "\""
            elif type(val) is dict:
                return "Error: " + word + " is a dictionary"
            else:
                while not is_float(val):
                    val = str(do_eval(val, scope))
                exp_w_subs.append(val)

    # eprint(exp_w_subs)

    return eval(' '.join(exp_w_subs))

def update_scope_and_then(scope, old_scope_lv, linenum, passthrough_re):
    indent_lv = 0
    new_subscope = ""
    just_augmented_scope = False
    and_then = None

    if m := new_subscope_re.match(line):
        indent_lv = len(m.group(1))
        new_subscope = m.group(2)

        just_augmented_scope = True
        and_then = None

    elif m := passthrough_re.match(line):
        indent_lv = len(m.group(1))
        new_subscope = ""

        and_then = m

    new_scope_lv = int(indent_lv / update_scope_and_then.INDENT_UNIT)
    lv_change = new_scope_lv - old_scope_lv

    just_previously_augmented_scope = update_scope_and_then.just_previously_augmented_scope
    # TODO: Check why this does not work
    # if not just_previously_augmented_scope:
    #     assert lv_change <= 0, "Indentation error at line " + str(linenum)
    update_scope_and_then.just_previously_augmented_scope = just_augmented_scope

    if lv_change < 0 or (lv_change == 0 and just_previously_augmented_scope):
        scope = scope[:new_scope_lv]

    if len(new_subscope) != 0: scope.append(new_subscope)
    
    return and_then, scope, new_scope_lv
# STATICS
update_scope_and_then.just_previously_augmented_scope = False
update_scope_and_then.INDENT_UNIT = 4

########
# Main #
########

# Get contents of file
lines = sys.stdin.read().split('\n')

# First pass: get variables
cur_scope_lv = 0
scope = []
just_augmented_scope = False
for [linenum, line] in enumerate(lines):
    if whitespace_re.match(line):
        continue

    if list_ele_re.match(line):
        continue

    if heading_re.match(line):
        continue

    m, scope, cur_scope_lv = update_scope_and_then(scope, cur_scope_lv, linenum, keyval_pair_re)
    if m:
        name = m.group(2)
        val = m.group(4)

        dict_add_dotted_str(env, add_scope(scope, name), val, True)

eprint(env, end = '')

try:
    splitPoint = next(filter(lambda e: e[1].strip() == "# STORAGE", enumerate(lines)))[0]
except:
    splitPoint = -1

if splitPoint == -1:
    body = lines
    storage = []
else:
    body = lines[0:splitPoint]
    storage = lines[splitPoint+1:]

# eprint(body)
# eprint(storage)

malformed_storage = False
try:
    cached_exps = yaml.safe_load('\n'.join(storage)) or {}
except:
    eprint("Error: Malformed STORAGE section")
    malformed_storage = True
    cached_exps = {}

# for line in body:
#     print(
#         re.sub(
#             r'^(\s*)(.*)\s*:(.)>\s*(.*)$',
#             do_eval_in_sub,
#             line
#         )
#     )

scope = []
cur_scope_lv = 0
for [linenum, line] in enumerate(body):
    if whitespace_re.match(line) or list_ele_re.match(line) or heading_re.match(line):
        print(line)
        continue

    m, scope, cur_scope_lv = update_scope_and_then(scope, cur_scope_lv, linenum, keyval_pair_re)

    if m:
        control_sequence = m.group(3)
        if control_sequence:
            print(do_eval_in_sub(scope, m))
        else:
            print(line)
    else:
        print(line)

if malformed_storage:
    print()
    print("# MALFORMED STORAGE BU")
    print(''.join(storage))

# WARNING: STORAGE must be the last section of the doc!!
if len(cached_exps) > 0:
    print("# STORAGE", end = '\n\n')
    print(yaml.dump(cached_exps))
